---
layout: post
title: 文字列をビット列に変換する関数を定義してみる
date: 2015-09-26 00:00:00
---

## 文字列をビット列に変換する関数を定義してみる

文字をビット列に変換する関数を使って、文字列をビット列に変換する関数を定義してみる。

{% highlight haskell %}
data Bit = Zero | One deriving Show
type CodeTable = [(Char, [Bit])]
char2bits :: CodeTable -> Char -> [Bit]
char2bits ((x, bs):ts) y = if x == y then bs else char2bits ts y
string2bits :: CodeTable -> [Char] -> [Bit]
string2bits ts xs = concat $ map (char2bits ts) xs
{% endhighlight %}

確認したいですね。

## 手動でテーブルを作成してみる

確認するために、テーブルを作成してみる。

{% highlight haskell %}
table = [('a', [Zero]),
         ('b', [One, Zero]),
         ('c', [One, One, Zero]),
         ('d', [One, One, One, Zero]),
         ('e', [One, One, One, One, Zero]),
         ('f', [One, One, One, One, One, Zero]),
         ('g', [One, One, One, One, One, One, Zero]),
         ('h', [One, One, One, One, One, One, One, Zero]),
         ('i', [One, One, One, One, One, One, One, One, Zero]),
         ('j', [One, One, One, One, One, One, One, One, One, Zero]),
         ('k', [One, One, One, One, One, One, One, One, One, One, Zero]),
         ('l', [One, One, One, One, One, One, One, One, One, One, One, Zero]),
         ('m', [One, One, One, One, One, One, One, One, One, One, One, One, Zero]),
         ('n', [One, One, One, One, One, One, One, One, One, One, One, One, One, Zero]),
         ('o', [One, One, One, One, One, One, One, One, One, One, One, One, One, One, Zero]),
         ('p', [One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, Zero]),
         ('q', [One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, Zero]),
         ('r', [One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, Zero]),
         ('s', [One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, Zero]),
         ('t', [One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, Zero]),
         ('u', [One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, Zero]),
         ('v', [One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, Zero]),
         ('w', [One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, Zero]),
         ('x', [One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, Zero]),
         ('y', [One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, Zero]),
         ('z', [One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, Zero]),
         (' ', [One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, One, Zero])
        ]
{% endhighlight %}

このテーブルを使って、英小文字と半角スペースはエンコードできるはずです。

## ghciで確認してみる

確認するためには、ここまでの定義をhuffman.hsに保存しておく必要があります。

{% highlight haskell %}
$ ghci
Prelude> :load huffman.hs
*Main> string2bits table "it is pm seven in tokyo"
{% endhighlight %}

## まとめ

文字列をビット列に変換する関数を定義して、手動でテーブルを作成して、REPLで確認しました。

任意の文字列からテーブルを作成する関数を定義したいですね。

少し大きなタスクになりそうなので、いくつかのタスクに分割したほうが良さそうです。

先は長いです。。
