---
layout: post
title: Huffman木を作成する関数を定義してみる
date: 2015-09-28 00:00:00
---

## 型を定義してみる

TipがHuffman木の端点(以下、端点)となり、NodeがHuffman木の分岐(以下、分岐)となる型を定義してみる。

{% highlight haskell %}
data Huff = Tip Int Char | Node Int Huff Huff deriving Show
{% endhighlight %}

huffman.hsに定義を追加して、早速使ってみる。

{% highlight haskell %}
Prelude> :load huffman.hs
*Main> Tip 5 'a'
Tip 5 'a'
*Main> Node 11 (Tip 5 'a') (Tip 6 'b')
Node 11 (Tip 5 'a') (Tip 6 'b')
{% endhighlight %}

良さそうですね。

二分木と似ていますが、２つ違いがあります。

- 型変数がない
- 端点と分岐に重み(Int型)がある

端点の重みはその文字の出現回数で、分岐の重みは部分木の重みの和です。

## タプルから端点を作成する関数を定義してみる

文字とその文字の出現回数のタプルから端点を作成する関数を定義してみる。

{% highlight haskell %}
mkTip :: (Char, Int) -> Huff
mkTip (c, w) = Tip w c
{% endhighlight %}

huffman.hsに定義を追加して、早速使ってみる。

{% highlight haskell %}
*Main> :load huffman.hs
*Main> mkTip ('a', 5)
Tip 5 'a'
*Main> mkTip ('b', 6)
Tip 6 'b'
{% endhighlight %}

良さそうですね。

## 単一要素のリストかどうかを判定する関数を定義してみる

Huffman木を組み立てるために、あとで使う関数です。

リストのサイズが１のときにTrueを返し、それ以外のときにFalseを返す関数です。

{% highlight haskell %}
singleton :: [Huff] -> Bool
singleton (x:[]) = True
singleton (x:xs) = False
{% endhighlight %}

huffman.hsに定義を追加して、早速使ってみる。

{% highlight haskell %}
Prelude> :load huffman.hs
*Main> singleton [Tip 2 'o', Tip 1 'k']
False
*Main> singleton [Tip 2 'o']
True
{% endhighlight %}

良さそうですね。

## 重みを取得する関数を定義してみる

重みの昇順に整列するために、重みを取得する関数を定義してみる。

{% highlight haskell %}
weight :: Huff -> Int
weight (Tip w c)    = w
weight (Node w x y) = w
{% endhighlight %}

huffman.hsに定義を追加して、早速使ってみる。

{% highlight haskell %}
Prelude> :load huffman.hs
*Main> map weight [Tip 2 'o', Tip 1 'k']
[2,1]
{% endhighlight %}

良さそうですね。

## 端点のリストに端点を挿入する関数を定義してみる

この関数は重みの昇順を保つように端点を挿入します。

{% highlight haskell %}
insert :: Huff -> [Huff] -> [Huff]
insert xt yts = uts ++ [xt] ++ vts
                where (uts, vts) = span (\yt -> weight yt <= weight xt) yts
{% endhighlight %}

huffman.hsに定義を追加して、早速使ってみる。

{% highlight haskell %}
*Main> :load huffman.hs
*Main> Main.insert (Tip 1 'a') [(Tip 2 'b'), (Tip 4 'c')]
[Tip 1 'a',Tip 2 'b',Tip 4 'c']
*Main> Main.insert (Tip 3 'a') [(Tip 2 'b'), (Tip 4 'c')]
[Tip 2 'b',Tip 3 'a',Tip 4 'c']
*Main> Main.insert (Tip 5 'a') [(Tip 2 'b'), (Tip 4 'c')]
[Tip 2 'b',Tip 4 'c',Tip 5 'a']
*Main> Main.insert (Tip 5 'a') []
[Tip 5 'a']
{% endhighlight %}

Data.List.insertと名前が衝突しますが、良さそうですね。

## 部分木を作成する関数を定義してみる

Huffman木を組み立てるために、あとで使う関数です。

{% highlight haskell %}
combine :: [Huff] -> [Huff]
combine (xt:yt:xts) = Main.insert (Node w xt yt) xts
                      where w = weight xt + weight yt
{% endhighlight %}

huffman.hsに定義を追加して、早速使ってみる。

{% highlight haskell %}
Prelude> :load huffman.hs
*Main> combine [(Tip 1 'a'), (Tip 2 'b')]
[Node 3 (Tip 1 'a') (Tip 2 'b')]
*Main> combine [(Tip 1 'a'), (Tip 2 'b'), (Tip 3 'c')]
[Tip 3 'c',Node 3 (Tip 1 'a') (Tip 2 'b')]
*Main> combine [(Tip 1 'a'), (Tip 2 'b'), (Tip 3 'c'), (Tip 4 'd')]
[Tip 3 'c',Node 3 (Tip 1 'a') (Tip 2 'b'),Tip 4 'd']
*Main> combine [(Tip 1 'a'), (Tip 1 'b'), (Tip 3 'c'), (Tip 4 'd')]
[Node 2 (Tip 1 'a') (Tip 1 'b'),Tip 3 'c',Tip 4 'd']
*Main> combine [(Tip 1 'a'), (Tip 4 'b'), (Tip 3 'c'), (Tip 4 'd')]
[Tip 3 'c',Tip 4 'd',Node 5 (Tip 1 'a') (Tip 4 'b')]
{% endhighlight %}

良さそうですね。

insert関数のおかげで、この関数は重みの昇順を保つように部分木を挿入します。

## Huffman木を作成する関数を定義してみる

タプルから端点を作成して、リストのサイズが１になるまでHuffman木を組み立て続けます。

{% highlight haskell %}
mkHuff :: [(Char, Int)] -> Huff
mkHuff = head . until singleton combine . map mkTip
{% endhighlight %}

huffman.hsに定義を追加して、早速使ってみる。

{% highlight haskell %}
*Main> :load huffman.hs
*Main> sample "tokyo"
[('o',2),('y',1),('t',1),('k',1)]
*Main> mkHuff $ sample "tokyo"
Node 5 (Node 2 (Tip 1 't') (Tip 1 'k')) (Node 3 (Tip 2 'o') (Tip 1 'y'))
*Main> sample "It is pm seven in Tokyo"
[(' ',5),('s',2),('o',2),('n',2),('i',2),('e',2),('y',1),('v',1),('t',1),('p',1),('m',1),('k',1),('T',1),('I',1)]
*Main> mkHuff $ sample "It is pm seven in Tokyo"
Node 23 (Node 8
          (Node 4 (Node 2 (Tip 1 'y') (Tip 1 'v')) (Node 2 (Tip 1 't') (Tip 1 'p')))
          (Node 4 (Node 2 (Tip 1 'm') (Tip 1 'k')) (Node 2 (Tip 1 'T') (Tip 1 'I')))) 
        (Node 15
          (Node 7 (Tip 5 ' ') (Tip 2 's'))
          (Node 8 (Node 4 (Tip 2 'o') (Tip 2 'n')) (Node 4 (Tip 2 'i') (Tip 2 'e'))))
{% endhighlight %}

良さそうですね。

## まとめ

ほとんどの関数の定義は『関数プログラミング入門 Haskellで学ぶ原理と技法』の写経ですが、所々補足しました。

Huffman木を作成する関数を定義しました。

あとは、符号化と復号ですね。

