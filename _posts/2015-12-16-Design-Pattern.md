---
layout: post
title: Design Pattern
date: 2015-12-16 00:00:00
---

## まえがき

『Rubyによるデザインパターン』を読んでいます。

この書籍には14個のデザインパターンがあります。

- Template Method Pattern
- Strategy Pattern
- Observer Pattern
- Composite Pattern
- Iterator Pattern
- Command Pattern
- Adapter Pattern
- Proxy Pattern
- Decorator Pattern
- Singleton Pattern
- Factory Method Pattern
- Abstract Factory Pattern
- Builder Pattern
- Interpreter Pattern

各デザインパターンについて簡単に復習してみたいと思います。

## Template Method Pattern

処理の種類が複数あるときに、Template Method Patternを使います。

例えば、HTMLのフォーマットでレポートを出力したり、XMLのフォーマットでレポートを出力したり、プレーンテキストのフォーマットでレポートを出力したり、CSVのフォーマットでレポートを出力したり、Excelのフォーマットでレポートを出力したりするシステムがあり、そのレポート出力ごとにフォーマット処理があるとします。

- HTMLのフォーマット処理
- XMLのフォーマット処理
- プレーンテキストのフォーマット処理
- CSVのフォーマット処理
- Excelのフォーマット処理

このようなシステムを実装するときに問題になることは「どのようにフォーマットの処理を用意するか？」ということです。

Template Method Patternでは継承でフォーマットの処理を用意します。

つまり、HTMLのフォーマット処理を担当するサブクラスがあり、XMLのフォーマット処理を担当するサブクラスがあり、プレーンテキストのフォーマット処理を担当するサブクラスがあり、・・・、Excelのフォーマット処理を担当するサブクラスがあるということです。

スーパークラスに変わらないところを担当させ、サブクラスに変わるところを担当させます。

呼び出し元はサブクラスのオブジェクトを生成して、スーパークラスのメソッドを呼び出します。

## Strategy Pattern

処理の種類が複数あるときに、Strategy Patternを使います。

用途はTemplate Method Patternと同じですが、委譲で処理を用意します。

委譲元に変わらないところを担当させ、委譲先に変わるところを担当させます。

Template Method PatternとStrategy Patternは似ていますが、継承ベースか委譲ベースかの違いがあります。

## Observer Pattern

ニュースを発行するクラスとニュースを購読するクラスを実装するときに使います。

ニュースを発行する側をサブジェクトと呼び、ニュースを購読する側をオブザーバと呼びます。

サブジェクトがオブザーバを呼び出します。

呼び出し先が呼び出し元の状態に関心があるような状況を実装するときに使います。

つまり、オブザーバがサブジェクトの状態に関心があるような状況を実装するときに使います。

具体的には、局所的な変化を大域的に報せるような仕組みを実装するときに使います。

## Composite Pattern

オブジェクトのコレクションを取り扱うときに使います。

コンポジット(複合。混成。合成。)をコンポーネント(構成要素。構成部品。)と同じように取り扱いたいときに使います。

## Iterator Pattern

オブジェクトのコレクションを取り扱うときに使います。

外部イテレータと内部イテレータがあります。

外部イテレータとはイテレータが集約オブジェクトではないイテレータのことです。

C++のstd::vector&lt;T&gt;::iteratorなどです。この場合の集約オブジェクトはstd::vector&lt;T&gt;になります。

内部イテレータとはイテレータが集約オブジェクトであるイテレータのことです。

Rubyのeachメソッドを持つオブジェクトやScalaのmapメソッドを持つオブジェクトなどです。

## Command Pattern

Observer Patternと似ていますが、呼び出し先が呼び出し元の状態に関心がないような状況を実装するときに使います。

つまり、呼び出し先の処理は呼び出し元に実行タイミングのみ依存する感じです。

Composite Patternと併用することもあるようです。

## Adapter Pattern

不適切なインタフェースを持つオブジェクトを適切なインタフェースを持つオブジェクトでラップするものです。

外部ライブラリのインタフェースなどを変更して、利用したいときなどに使います。

## Proxy Pattern

オブジェクトをオブジェクトでラップするものです。

インタフェースを変える意図はありません。

ラップされるオブジェクトとラップするオブジェクトのインタフェースは同じインタフェースです。

処理の間にちょっとした制御を差し込みたいときなどに使います。

## Decorator Pattern

レイヤ状に機能を追加したいときなどに使います。

## Singleton Pattern

オブジェクトの生成を抑制したいときなどに使います。

## Factory Method Pattern

Template Method Patternと似ていますが、オブジェクトの生成に関連するデザインパターンです。

普通のクラスは自分自身のクラスのオブジェクトの作り方は知っていますが、自分自身のクラス以外のオブジェクトの作り方は知りません。

自分自身のクラス以外のオブジェクトを用意したいときに、「どのようにオブジェクトを用意するか？」という問題があります。

Factory Method Patternでは継承でオブジェクトを用意します。

## Abstract Factory Pattern

Strategy Patternと似ていますが、オブジェクトの生成に関連するデザインパターンです。

自分自身のクラス以外のオブジェクトを用意したいときに、「どのようにオブジェクトを用意するか？」という問題があります。

Abstract Factory Patternでは委譲でオブジェクトを用意します。

## Builder Pattern

複雑なオブジェクトを構築したいときに使います。

## Interpreter Pattern

単純な処理から複雑な処理を構築したいときに使います。

パーサを用意する場合とパーサを用意しない場合があります。

パーサを用意しない場合のほうが手間が少ないです。

## あとがき

漫然と読むだけでは「何が違うのか」ということに気付けませんでした。

このデザインパターンとあのデザインパターンはここが似ているけれど、名前が違う。なぜ名前が違うのだろうか？

名前が違うことがヒントになったり、著者のデザインパターンについての感想がヒントになったりしました。

試しに実装してみることも理解の助けになりました。
