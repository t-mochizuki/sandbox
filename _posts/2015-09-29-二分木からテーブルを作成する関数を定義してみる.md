---
layout: post
title: 二分木からテーブルを作成する関数を定義してみる
date: 2015-09-29 00:00:00
---

## 型を定義してみる

二分木の型を定義してみる。

{% highlight haskell %}
data Btree a = Leaf a | Fork (Btree a) (Btree a) deriving Show
{% endhighlight %}

## Huffman木から二分木を作成する関数を定義してみる

Huffman木から二分木を作成する関数を定義してみる。

{% highlight haskell %}
huff2btree :: Huff -> Btree Char
huff2btree (Tip w c)      = Leaf c
huff2btree (Node w xt yt) = Fork (huff2btree xt) (huff2btree yt)
{% endhighlight %}

## テーブルをマージする関数を定義してみる

テーブルをマージする関数を定義してみる。

{% highlight haskell %}
huffmerge :: CodeTable -> CodeTable -> CodeTable
huffmerge [] yts = [(y, One:ybs)  | (y, ybs) <- yts]
huffmerge xts [] = [(x, Zero:xbs) | (x, xbs) <- xts]
huffmerge ((x, xbs):xts) ((y, ybs):yts)
    | length xbs <= length ybs = (x, Zero:xbs):huffmerge xts ((y, ybs):yts)
    | otherwise                = (y, One:ybs):huffmerge ((x, xbs):xts) yts
{% endhighlight %}

## 二分木からテーブルを作成する関数を定義してみる

二分木からテーブルを作成する関数を定義してみる。

{% highlight haskell %}
transform :: Btree Char -> CodeTable
transform (Leaf c)     = [(c, [])]
transform (Fork xt yt) = huffmerge (transform xt) (transform yt)
{% endhighlight %}

## string2bits関数を使って符号化してみる

string2bits関数を使って符号化してみる。

{% highlight haskell %}
*Main> string2bits (transform $ huff2btree $ mkHuff $ sample "It is pm sevene in Tokyo") ("It is pmseven in Tokyo")
{% endhighlight %}

## 符号化された文字列を復号する関数を定義してみる

符号化された文字列を復号する関数を定義してみる。

{% highlight haskell %}
decode :: Btree Char -> [Bit] -> [Char]
decode t bs = if null bs then [] else decode' t bs
              where decode' (Leaf c) bs = c:decode t bs
                    decode' (Fork xt yt) (Zero:bs) = decode' xt bs
                    decode' (Fork xt yt) (One:bs)  = decode' yt bs
{% endhighlight %}

早速使ってみる。

{% highlight haskell %}
*Main> :load huffman.hs
*Main> let text = "It is pm seven in Tokyo"
*Main> let tree = huff2btree $ mkHuff $ sample text
*Main> let table = transform tree
*Main> let encode = string2bits table text
*Main> decode tree encode
"It is pm seven in Tokyo"
{% endhighlight %}

良さそうですね。

## まとめ

符号化と復号ができました。

長かった。

現在のhuffman.hsです。

{% highlight haskell %}
import Data.List

data Bit = Zero | One deriving Show

type CodeTable = [(Char, [Bit])]

char2bits :: CodeTable -> Char -> [Bit]
char2bits ((x, bs):ts) y = if x == y then bs else char2bits ts y

string2bits :: CodeTable -> [Char] -> [Bit]
string2bits ts xs = concat $ map (char2bits ts) xs

collate :: [Char] -> [(Char, Int)]
collate []     = []
collate (x:xs) = (x, 1 + length ys):collate zs
                 where (ys, zs) = span (== x) xs

sample :: [Char] -> [(Char, Int)]
sample = reverse . sortOn snd . collate . sort

bits :: Int -> [Bit]
bits n = (replicate n One) ++ [Zero]

mkTable :: [Char] -> CodeTable
mkTable xs = zip (map fst $ sample xs) (map bits [0..])

encode :: [Char] -> [Bit]
encode xs = string2bits (mkTable xs) xs

data Huff = Tip Int Char | Node Int Huff Huff deriving Show

mkTip :: (Char, Int) -> Huff
mkTip (c, w) = Tip w c

singleton :: [Huff] -> Bool
singleton (x:[]) = True
singleton (x:xs) = False

weight :: Huff -> Int
weight (Tip w c)    = w
weight (Node w x y) = w

insert :: Huff -> [Huff] -> [Huff]
insert xt yts = uts ++ [xt] ++ vts
                where (uts, vts) = span (\yt -> weight yt <= weight xt) yts

combine :: [Huff] -> [Huff]
combine (xt:yt:xts) = Main.insert (Node w xt yt) xts
                      where w = weight xt + weight yt

mkHuff :: [(Char, Int)] -> Huff
mkHuff = head . until singleton combine . map mkTip

data Btree a = Leaf a | Fork (Btree a) (Btree a) deriving Show

huff2btree :: Huff -> Btree Char
huff2btree (Tip w c)      = Leaf c
huff2btree (Node w xt yt) = Fork (huff2btree xt) (huff2btree yt)

huffmerge :: CodeTable -> CodeTable -> CodeTable
huffmerge [] yts = [(y, One:ybs)  | (y, ybs) <- yts]
huffmerge xts [] = [(x, Zero:xbs) | (x, xbs) <- xts]
huffmerge ((x, xbs):xts) ((y, ybs):yts)
    | length xbs <= length ybs = (x, Zero:xbs):huffmerge xts ((y, ybs):yts)
    | otherwise                = (y, One:ybs):huffmerge ((x, xbs):xts) yts

transform :: Btree Char -> CodeTable
transform (Leaf c)     = [(c, [])]
transform (Fork xt yt) = huffmerge (transform xt) (transform yt)

decode :: Btree Char -> [Bit] -> [Char]
decode t bs = if null bs then [] else decode' t bs
              where decode' (Leaf c) bs = c:decode t bs
                    decode' (Fork xt yt) (Zero:bs) = decode' xt bs
                    decode' (Fork xt yt) (One:bs)  = decode' yt bs
{% endhighlight %}

