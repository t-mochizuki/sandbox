---
layout: post
title: 文字列からテーブルを作成する関数を定義してみる
date: 2015-09-27 00:00:00
---

## sort関数とspan関数を使ってみる

文字列から文字とその文字の出現回数のタプルのリストを作成する関数を定義するために、sort関数とspan関数を使ってみる。

sort関数を使うためには、Data.Listをインポートする必要があります。

{% highlight haskell %}
Prelude> import Data.List
Prelude Data.List> sort "tokyo"
"kooty"
Prelude Data.List> span (== 'k') "kooty"
("k","ooty")
Prelude Data.List> span (== 'o') "ooty"
("oo","ty")
Prelude Data.List> span (== 't') "ty"
("t","y")
Prelude Data.List> span (== 'y') "y"
("y","")
{% endhighlight %}

## 文字列から文字とその文字の出現回数のタプルのリストを作成する関数を定義してみる

{% highlight haskell %}
collate :: [Char] -> [(Char, Int)]
collate []     = []
collate (x:xs) = (x, 1 + length ys):collate zs
                 where (ys, zs) = span (== x) xs
{% endhighlight %}

huffman.hsに定義を追加して、早速使ってみる。

{% highlight haskell %}
Prelude> :load huffman.hs
*Main> collate "tokyo"
[('t',1),('o',1),('k',1),('y',1),('o',1)]
*Main> collate $ sort "tokyo"
[('k',1),('o',2),('t',1),('y',1)]
{% endhighlight %}

良さそうですね。

## 出現回数が多い順に整列してみる

出現回数が多い順に整列するために、タプルから出現回数を取得する関数を定義してみる。

{% highlight haskell %}
freq :: (Char, Int) -> Int
freq (x, m) = m
{% endhighlight %}

huffman.hsに定義を追加して、早速使ってみる。

{% highlight haskell %}
Prelude> :load huffman.hs
*Main> sortOn freq $ collate $ sort "tokyo"
[('k',1),('t',1),('y',1),('o',2)]
*Main> reverse . sortOn freq $ collate $ sort "tokyo"
[('o',2),('y',1),('t',1),('k',1)]
{% endhighlight %}

良さそうですね。

関数を定義してみる。

{% highlight haskell %}
sample :: [Char] -> [(Char, Int)]
sample = reverse . sortOn freq . collate . sort
{% endhighlight %}

これもhuffman.hsに追加する。

## タプルから文字を取得する関数と整数からビット列を作成する関数を定義してみる

出現回数が多い文字に短いバイト列を割り当てたい。

そのために、タプルから文字を取得する関数と整数からビット列を作成する関数を定義してみる。

{% highlight haskell %}
char :: (Char, Int) -> Char
char (x, m) = x

bits :: Int -> [Bit]
bits n = (replicate n One) ++ [Zero]
{% endhighlight %}

huffman.hsに定義を追加して、早速使ってみる。

{% highlight haskell %}
Prelude> :load huffman.hs
*Main> zip (map char $ sample "tokyo") (map bits [0..])
[('o',[Zero]),('y',[One,Zero]),('t',[One,One,Zero]),('k',[One,One,One,Zero])]
{% endhighlight %}

良さそうですね。

## 文字列からテーブルを作成する関数を定義してみる

{% highlight haskell %}
mkTable :: [Char] -> CodeTable
mkTable xs = zip (map char $ sample xs) (map bits [0..])
{% endhighlight %}

## まとめ

文字列からテーブルを作成して、文字列をビット列に変換してみる。

{% highlight haskell %}
Prelude> :load huffman.hs
*Main> let table = mkTable "tokyo"
*Main> string2bits table "tokyo"
[One,One,Zero,Zero,One,One,One,Zero,One,Zero,Zero]
{% endhighlight %}

良さそうですね。

Huffman符号化ではありませんが、テキストを符号化できました。

今更ですが、freq関数とchar関数の代わりにsnd関数とfst関数が使えそうですね。

次は、Huffman木か復号です。

先は、長いです。。
